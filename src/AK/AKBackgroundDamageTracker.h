#ifndef AKBACKGROUNDDAMAGETRACKER_H
#define AKBACKGROUNDDAMAGETRACKER_H

#include <AK/AKObject.h>
#include <include/core/SkRegion.h>

/**
 * @brief Background capturer.
 *
 * This utility class is present in all AKNodes and is used to capture
 * the content behind the node. It only captures the content if enabled
 * and if the node is visible.
 *
 * It is used by effects like AKBackgroundBlurEffect, which need access
 * to the content behind the node to re-render it with some processing applied.
 *
 * During an AKScene::render() pass, the scene does not render the background content
 * directly into the scene target as usual. Instead, it is rendered into an AKSurface
 * provided by this object.
 *
 * This captured content can later be accessed, for example, in AKRenderable::renderEvent().
 *
 * This means it is the node's responsibility to later draw the background content
 * into the scene target, either as-is or with effects applied. Not doing so may lead to
 * unexpected results.
 *
 * The capture rect, relative to the associated node, determines which area to capture.
 * It may extend beyond the node's bounds. However, the scene does not always capture
 * the entire rect, only the damage generated by background nodes. The damageOutset() property
 * can be used to expand each rectangle of the captured damage region. This is particularly useful for
 * effects like blur, where surrounding pixels are needed.
 *
 * In certain cases, it may be necessary to ensure that parts of the captured background
 * are also rendered into the scene target as usual. For example, when applying a blur
 * effect to a node with a rounded rectangle mask, the corners will not only consist of blur,
 * so the real background must exist underneath to preserve the intended visual composition.
 *
 * The surfaces used for capturing always have the same logical size as their
 * respective scene target, however, their buffer size may vary depending on the
 * selected scale().
 *
 * For example, blur effects can benefit from capturing content at a lower resolution,
 * where image quality is less critical since it will be blurred anyway.
 *
 * Additionally, the scene can ensure the surface size is divisible by a specified factor
 * using the divisibleBy() property. If necessary, the scene will increase the surface size
 * until it meets this requirement.
 *
 * During events such as AKRenderable::renderEvent(), the captureRectTranslated(),
 * paintAnywayTranslated(), capturedDamage() and currentSurface() properties provide
 * all the necessary information to re-render the captured background with any desired effect.
 */
class AK::AKBackgroundDamageTracker : public AKObject
{
public:

    /**
     * @brief A map of surfaces created by this tracker.
     *
     * The tracker creates a dedicated surface for each scene target in which the node is presented.
     *
     * Each surface always has the same logical size as its associated target, but its actual buffer size may vary
     * depending on the selected scale().
     *
     * Even if the scene matches the size of the target, only the region defined by capturedRegion()
     * is guaranteed to be present in the surface. The scene ignores regions where no damage has occurred
     * during AKScene::render().
     */
    const std::unordered_map<AKSceneTarget*,std::shared_ptr<AKSurface>> &surfaces() const noexcept
    {
        return m_surfaces;
    }

    /**
     * @brief Retrieves the current capture surface.
     *
     * Returns the surface where the content was captured during the current AKScene::render() pass.
     *
     * If `nullptr`, it indicates that the tracker was disabled or the node was not visible during the frame.
     *
     * @return A shared pointer to the current capture surface, or `nullptr` if unavailable.
     */
    std::shared_ptr<AKSurface> currentSurface() const noexcept
    {
        return m_currentSurface;
    }

    /**
     * @brief Enables or disables the damage tracker.
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * The damage tracker is disabled by default.
     *
     * @note Even if enabled, no content will be captured unless the node is visible.
     */
    void setEnabled(bool enabled) noexcept
    {
        m_enabled = enabled;
    };

    /**
     * @brief Checks whether the damage tracker is enabled.
     *
     * @see setEnabled()
     */
    bool enabled() const noexcept { return m_enabled; };

    /**
     * @brief The rect to capture.
     *
     * The specified rect is relative to the top-left corner of the node.
     *
     * The scene will render any damaged region that falls within this rect
     * onto the tracker surface instead of the scene target, except for areas
     * defined by repaintAnyway() which will be rendered in both.
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * The default capture rect is (0, 0, 0, 0).
     */
    void setCaptureRect(const SkIRect &rect) noexcept
    {
        m_captureRect = rect;
    }

    /**
     * @brief Retrieves the current capture rect.
     *
     * @see setCaptureRect()
     */
    const SkIRect &captureRect() const noexcept
    {
        return m_captureRect;
    }

    /**
     * @brief The translated capture rectangle.
     *
     * Returns the captureRect() translated by the current node AKNode::sceneRect() position.
     *
     * @note This value is set by the scene during AKScene::render().
     *
     * @see setCaptureRect()
     */
    const SkIRect &captureRectTranslated() const noexcept
    {
        return m_captureRectTranslated;
    }

    /**
     * @brief Forces a specific region to be painted into the scene target.
     *
     * By default, the captured region is rendered only in the tracker surface.
     *
     * This setting allows you to specify a region that should be rendered
     * into the scene target as usual.
     *
     * This is useful in scenarios where the captured content is later rendered with a mask,
     * and parts of the original background must remain visible as usual.
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * Empty by default.
     */
    void setPaintAnyway(const SkRegion &region) noexcept
    {
        m_paintAnyway = region;
    }

    /**
     * @brief Region forced to be painted into the scene target.
     *
     * @see setPaintAnyway()
     */
    const SkRegion &paintAnyway() const noexcept
    {
        return m_paintAnyway;
    }

    /**
     * @brief The translated region to paint anyway.
     *
     * Returns the paintAnyway() region translated by the current node AKNode::sceneRect() position.
     *
     * @note This value is set by the scene during AKScene::render().
     *
     * @see setPaintAnyway()
     */
    const SkRegion &paintAnywayTranslated() const noexcept
    {
        return m_paintAnywayTranslated;
    }

    /**
     * @brief Sets the scale factor for the surface.
     *
     * To avoid quality loss, the scale factor should match that of the scene target.
     *
     * However, using a smaller scale can improve performance and is useful for effects
     * like blur, where downscaling is necessary and the quality reduction is beneficial.
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * TODO: Add an option to weight the scale relative to the target scale.
     *
     * The default value is 1.f.
     *
     * @param scale The scale factor. The minimum allowed value is 0.0625f.
     */
    void setScale(SkScalar scale) noexcept
    {
        if (scale < 0.0625f)
            scale = 0.0625f;
        m_scale = scale;
    }

    /**
     * @brief The scale factor of the surface.
     *
     * @see setScale()
     */
    SkScalar scale() const noexcept
    {
        return m_scale;
    }

    /**
     * @brief Ensures surfaces have a buffer size divisible by the specified factor.
     *
     * If the surface size is not a multiple of the given factor, the scene
     * will increase the size until it meets the requirement.
     *
     * The default value is 1.
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * @param factor Must be >= 1.
     */
    void setDivisibleBy(Int32 factor) noexcept
    {
        if (factor < 1)
            factor = 1;

        m_divisibleBy = factor;
    }

    /**
     * @brief Retrieves the buffer size divisibility factor.
     *
     * @see setDivisibleBy()
     */
    Int32 divisibleBy() const noexcept
    {
        return m_divisibleBy;
    }

    /**
     * @brief The node this damage tracker belongs to.
     */
    AKNode &node() const noexcept { return m_node; };

    /**
     * @brief Defines an additional outset for the captured damage.
     *
     * This expands each rectangle of the captured damage by the specified amount,
     * ensuring that the surrounding areas are also rendered onto the surface.
     *
     * This affects capturedDamage().
     *
     * @note This action will take effect during the next AKScene::render() pass
     *       and does not automatically trigger a repaint.
     *
     * The default value is 0.
     *
     * @param outset The additional outset. Minimum allowed value is 0.
     */
    void setDamageOutset(Int32 outset) noexcept
    {
        if (outset < 0)
            outset = 0;

        m_damageOutset = outset;
    }

    /**
     * @brief Retrieves the additional outset applied to captured damage.
     *
     * @see setDamageOutset()
     */
    Int32 damageOutset() const noexcept
    {
        return m_damageOutset;
    }

    /**
     * @brief Captured damage region.
     *
     * This region contains all the damage rendered onto the current surface
     * during the ongoing AKScene::render() pass.
     *
     * The coordinates of this region match those of AKNode::sceneRect().
     *
     * It is automatically cleared at the beginning of AKScene::render().
     */
    SkRegion capturedDamage;

protected:
    friend class AKNode;
    friend class AKScene;
    AKBackgroundDamageTracker(AKNode &node) noexcept :
        m_node(node)
    {}

private:
    SkRegion m_capturedDamage;
    SkIRect m_captureRect { 0, 0, 0, 0};
    SkIRect m_captureRectTranslated;
    SkRegion m_paintAnyway;
    SkRegion m_paintAnywayTranslated;
    AKNode &m_node;
    SkScalar m_scale { 1.f };
    Int32 m_divisibleBy { 1 };
    Int32 m_damageOutset { 0 };
    std::unordered_map<AKSceneTarget*,std::shared_ptr<AKSurface>> m_surfaces;
    std::shared_ptr<AKSurface> m_currentSurface;
    bool m_enabled { false };
};

#endif // AKBACKGROUNDDAMAGETRACKER_H
