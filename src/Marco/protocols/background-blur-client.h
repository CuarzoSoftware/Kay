/* Generated by wayland-scanner 1.23.0 */

#ifndef BACKGROUND_BLUR_CLIENT_PROTOCOL_H
#define BACKGROUND_BLUR_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_background_blur The background_blur protocol
 * @section page_ifaces_background_blur Interfaces
 * - @subpage page_iface_background_blur_manager - background blur manager
 * - @subpage page_iface_background_blur - blur effect applied to the background of a surface
 * @section page_copyright_background_blur Copyright
 * <pre>
 *
 * Copyright Â© 2025 Cuarzo Software
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct background_blur;
struct background_blur_manager;
struct svg_path;
struct wl_region;
struct wl_surface;

#ifndef BACKGROUND_BLUR_MANAGER_INTERFACE
#define BACKGROUND_BLUR_MANAGER_INTERFACE
/**
 * @page page_iface_background_blur_manager background_blur_manager
 * @section page_iface_background_blur_manager_desc Description
 *
 * This interface allows a compositor to announce support for blurring the 
 * backgrounds of surfaces.
 * @section page_iface_background_blur_manager_api API
 * See @ref iface_background_blur_manager.
 */
/**
 * @defgroup iface_background_blur_manager The background_blur_manager interface
 *
 * This interface allows a compositor to announce support for blurring the 
 * backgrounds of surfaces.
 */
extern const struct wl_interface background_blur_manager_interface;
#endif
#ifndef BACKGROUND_BLUR_INTERFACE
#define BACKGROUND_BLUR_INTERFACE
/**
 * @page page_iface_background_blur background_blur
 * @section page_iface_background_blur_desc Description
 *
 * Starting from version 2, clients are permitted to clip the blur region using a 
 * round rect.
 *
 * Starting from version 3, clients are permitted to clip the blur region using an 
 * svg_path object.
 *
 * The set_region request is used to define the blur area in local surface coordinates. 
 * Optional clipping can be applied using either set_round_rect_clip or set_svg_path_clip 
 * (setting one replaces the other).
 *
 * The final blur area is the intersection of the surface bounds, the blur region, and 
 * the optional additional clipping.
 *
 * Providing only clipping without a region is the same as having an empty region.
 *
 * The client should avoid rendering completely opaque content within the blur area while 
 * enabled and should ideally mark it as invisible using the invisible-region protocol if 
 * the region is 100% transparent.
 *
 * In order for the blur to take effect, the compositor must send an enabled state 
 * event, a configure event, and the client must ACK and commit a null or non-empty 
 * region.
 *
 * The same applies afterwards, the compositor should keep the effect state and style 
 * until the client acknowledges and commits a new configuration.
 *
 * The initial blur area is an empty region (no blur).
 * @section page_iface_background_blur_api API
 * See @ref iface_background_blur.
 */
/**
 * @defgroup iface_background_blur The background_blur interface
 *
 * Starting from version 2, clients are permitted to clip the blur region using a 
 * round rect.
 *
 * Starting from version 3, clients are permitted to clip the blur region using an 
 * svg_path object.
 *
 * The set_region request is used to define the blur area in local surface coordinates. 
 * Optional clipping can be applied using either set_round_rect_clip or set_svg_path_clip 
 * (setting one replaces the other).
 *
 * The final blur area is the intersection of the surface bounds, the blur region, and 
 * the optional additional clipping.
 *
 * Providing only clipping without a region is the same as having an empty region.
 *
 * The client should avoid rendering completely opaque content within the blur area while 
 * enabled and should ideally mark it as invisible using the invisible-region protocol if 
 * the region is 100% transparent.
 *
 * In order for the blur to take effect, the compositor must send an enabled state 
 * event, a configure event, and the client must ACK and commit a null or non-empty 
 * region.
 *
 * The same applies afterwards, the compositor should keep the effect state and style 
 * until the client acknowledges and commits a new configuration.
 *
 * The initial blur area is an empty region (no blur).
 */
extern const struct wl_interface background_blur_interface;
#endif

#ifndef BACKGROUND_BLUR_MANAGER_ERROR_ENUM
#define BACKGROUND_BLUR_MANAGER_ERROR_ENUM
enum background_blur_manager_error {
	/**
	 * the surface already has an associated background blur object
	 */
	BACKGROUND_BLUR_MANAGER_ERROR_ALREADY_CONSTRUCTED = 0,
};
#endif /* BACKGROUND_BLUR_MANAGER_ERROR_ENUM */

#define BACKGROUND_BLUR_MANAGER_DESTROY 0
#define BACKGROUND_BLUR_MANAGER_GET_BACKGROUND_BLUR 1


/**
 * @ingroup iface_background_blur_manager
 */
#define BACKGROUND_BLUR_MANAGER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur_manager
 */
#define BACKGROUND_BLUR_MANAGER_GET_BACKGROUND_BLUR_SINCE_VERSION 1

/** @ingroup iface_background_blur_manager */
static inline void
background_blur_manager_set_user_data(struct background_blur_manager *background_blur_manager, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) background_blur_manager, user_data);
}

/** @ingroup iface_background_blur_manager */
static inline void *
background_blur_manager_get_user_data(struct background_blur_manager *background_blur_manager)
{
	return wl_proxy_get_user_data((struct wl_proxy *) background_blur_manager);
}

static inline uint32_t
background_blur_manager_get_version(struct background_blur_manager *background_blur_manager)
{
	return wl_proxy_get_version((struct wl_proxy *) background_blur_manager);
}

/**
 * @ingroup iface_background_blur_manager
 *
 * This doesn't destroy objects created with the manager.
 */
static inline void
background_blur_manager_destroy(struct background_blur_manager *background_blur_manager)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur_manager,
			 BACKGROUND_BLUR_MANAGER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur_manager), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_background_blur_manager
 *
 * The surface must not already have an associated background blur, otherwise 
 * the already_constructed error is emitted.
 *
 * Immediately after the object is created, the compositor will send a state 
 * event, a style event, and finally a configure event.
 *
 * Surfaces must acknowledge the configure event and may then define the blur 
 * region and optionally a round rect or SVG path for clipping before the next 
 * commit.
 *
 * The client may ignore all configure events except for the last one.
 *
 * A client can send multiple ack_configure requests before committing, but only 
 * the last request sent prior to the commit indicates which configure event the 
 * client is responding to.
 */
static inline struct background_blur *
background_blur_manager_get_background_blur(struct background_blur_manager *background_blur_manager, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) background_blur_manager,
			 BACKGROUND_BLUR_MANAGER_GET_BACKGROUND_BLUR, &background_blur_interface, wl_proxy_get_version((struct wl_proxy *) background_blur_manager), 0, NULL, surface);

	return (struct background_blur *) id;
}

#ifndef BACKGROUND_BLUR_ERROR_ENUM
#define BACKGROUND_BLUR_ERROR_ENUM
enum background_blur_error {
	/**
	 * surface destroyed before object
	 */
	BACKGROUND_BLUR_ERROR_DESTROYED_SURFACE = 0,
	/**
	 * invalid ack serial
	 */
	BACKGROUND_BLUR_ERROR_INVALID_SERIAL = 1,
	/**
	 * invalid round rect
	 * @since 2
	 */
	BACKGROUND_BLUR_ERROR_INVALID_ROUND_RECT = 2,
	/**
	 * invalid svg path
	 * @since 3
	 */
	BACKGROUND_BLUR_ERROR_INVALID_SVG_PATH = 3,
};
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ERROR_INVALID_ROUND_RECT_SINCE_VERSION 2
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ERROR_INVALID_SVG_PATH_SINCE_VERSION 3
#endif /* BACKGROUND_BLUR_ERROR_ENUM */

#ifndef BACKGROUND_BLUR_STATE_ENUM
#define BACKGROUND_BLUR_STATE_ENUM
enum background_blur_state {
	/**
	 * the blur effect is not displayed by the compositor
	 */
	BACKGROUND_BLUR_STATE_DISABLED = 0,
	/**
	 * the blur effect is displayed by the compositor
	 */
	BACKGROUND_BLUR_STATE_ENABLED = 1,
};
#endif /* BACKGROUND_BLUR_STATE_ENUM */

#ifndef BACKGROUND_BLUR_STYLE_ENUM
#define BACKGROUND_BLUR_STYLE_ENUM
enum background_blur_style {
	/**
	 * the blur effect has a dark tone
	 */
	BACKGROUND_BLUR_STYLE_DARK = 0,
	/**
	 * the blur effect has a light tone
	 */
	BACKGROUND_BLUR_STYLE_LIGHT = 1,
};
#endif /* BACKGROUND_BLUR_STYLE_ENUM */

/**
 * @ingroup iface_background_blur
 * @struct background_blur_listener
 */
struct background_blur_listener {
	/**
	 * set the blur effect state
	 *
	 * Specifies whether the blur effect is being applied by the
	 * compositor.
	 *
	 * If the effect is disabled, the surface no longer needs to make
	 * the blur area transparent.
	 *
	 * Must be followed by a configure event in order to take effect.
	 *
	 * The initial state is disabled.
	 * @param state The state of the blur effect.
	 */
	void (*state)(void *data,
		      struct background_blur *background_blur,
		      uint32_t state);
	/**
	 * set the color tone of the blur effect.
	 *
	 * The style specifies the color tone of the blur effect so that
	 * clients can adapt their content accordingly, for example,
	 * displaying white text if the tone is dark or black text if the
	 * tone is light.
	 *
	 * Must be followed by a configure event in order to take effect.
	 *
	 * The initial value is light.
	 * @param style The color tone of the blur effect.
	 */
	void (*style)(void *data,
		      struct background_blur *background_blur,
		      uint32_t style);
	/**
	 * notifies a blur effect change
	 *
	 * The configure event marks the end of a configure sequence.
	 *
	 * If the client receives multiple configure events before it can
	 * respond to one, it is free to discard all but the last event it
	 * received.
	 * @param serial serial of the configure event
	 */
	void (*configure)(void *data,
			  struct background_blur *background_blur,
			  uint32_t serial);
};

/**
 * @ingroup iface_background_blur
 */
static inline int
background_blur_add_listener(struct background_blur *background_blur,
			     const struct background_blur_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) background_blur,
				     (void (**)(void)) listener, data);
}

#define BACKGROUND_BLUR_DESTROY 0
#define BACKGROUND_BLUR_SET_REGION 1
#define BACKGROUND_BLUR_ACK_CONFIGURE 2
#define BACKGROUND_BLUR_CLEAR_CLIP 3
#define BACKGROUND_BLUR_SET_ROUND_RECT_CLIP 4
#define BACKGROUND_BLUR_SET_SVG_PATH_CLIP 5

/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_STATE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_STYLE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_REGION_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ACK_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_CLEAR_CLIP_SINCE_VERSION 2
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_ROUND_RECT_CLIP_SINCE_VERSION 2
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_SVG_PATH_CLIP_SINCE_VERSION 3

/** @ingroup iface_background_blur */
static inline void
background_blur_set_user_data(struct background_blur *background_blur, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) background_blur, user_data);
}

/** @ingroup iface_background_blur */
static inline void *
background_blur_get_user_data(struct background_blur *background_blur)
{
	return wl_proxy_get_user_data((struct wl_proxy *) background_blur);
}

static inline uint32_t
background_blur_get_version(struct background_blur *background_blur)
{
	return wl_proxy_get_version((struct wl_proxy *) background_blur);
}

/**
 * @ingroup iface_background_blur
 *
 * Switch back to a mode without background blur at the next commit.
 *
 * The object must be destroyed before the associated surface otherwise the 
 * destroyed_surface error is emitted.
 */
static inline void
background_blur_destroy(struct background_blur *background_blur)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_background_blur
 *
 * This is a double-buffered operation, refer to wl_surface.commit. 
 *
 * Setting the pending blur region has copy semantics, allowing the 
 * wl_region object to be destroyed immediately. 
 *
 * The region is defined in local surface coordinates and may extend
 * beyond the surface bounds.
 *
 * Setting a null region means that the blur area automatically adapts 
 * to the entire surface dimensions.
 *
 * The initial blur area is an empty region (no blur).
 */
static inline void
background_blur_set_region(struct background_blur *background_blur, struct wl_region *blur_region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_SET_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), 0, blur_region);
}

/**
 * @ingroup iface_background_blur
 *
 * Acknowledging a serial that has not been sent, or one that has already 
 * been acknowledged, triggers the invalid_serial error.
 */
static inline void
background_blur_ack_configure(struct background_blur *background_blur, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), 0, serial);
}

/**
 * @ingroup iface_background_blur
 *
 * This is a double-buffered operation, refer to wl_surface.commit. 
 *
 * This doesn't affect the blur region set with set_region.
 *
 * If no clipping was set previously, this is a no-op.
 */
static inline void
background_blur_clear_clip(struct background_blur *background_blur)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_CLEAR_CLIP, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), 0);
}

/**
 * @ingroup iface_background_blur
 *
 * This is a double-buffered operation, refer to wl_surface.commit.
 *
 * The round rect is defined in local surface coordinates and may extend
 * beyond the surface bounds.
 *
 * Setting a negative width, height, or radius, or if the sum of radii for an 
 * edge exceeds the dimensions for that axis, the invalid_round_rect error
 * is emitted.
 *
 * This request replaces any previously set clipping.
 */
static inline void
background_blur_set_round_rect_clip(struct background_blur *background_blur, int32_t x, int32_t y, int32_t width, int32_t height, int32_t radTL, int32_t radTR, int32_t radBR, int32_t radBL)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_SET_ROUND_RECT_CLIP, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), 0, x, y, width, height, radTL, radTR, radBR, radBL);
}

/**
 * @ingroup iface_background_blur
 *
 * This is a double-buffered operation, refer to wl_surface.commit.
 *
 * Setting the svg_path clip has copy semantics, allowing the 
 * svg_path object to be destroyed immediately. 
 *
 * The SVG path is defined in local surface coordinates and may extend
 * beyond the surface bounds.
 *
 * Setting an unconstructed or invalid path triggers the invalid_path error.
 *
 * This request replaces any previously set clipping.
 */
static inline void
background_blur_set_svg_path_clip(struct background_blur *background_blur, struct svg_path *path)
{
	wl_proxy_marshal_flags((struct wl_proxy *) background_blur,
			 BACKGROUND_BLUR_SET_SVG_PATH_CLIP, NULL, wl_proxy_get_version((struct wl_proxy *) background_blur), 0, path);
}

#ifdef  __cplusplus
}
#endif

#endif
